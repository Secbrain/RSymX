# The Detection Logic of Vulnerability Detectors

| **ID** | **Vulnerability Name**  | **Severity** | **ID** | **Vulnerability Name** | **Severity** |
| ------ | ----------------------- | ------------ | ------ | ---------------------- | ------------ |
| RE     | reentrancy-eth          | High         | UCL    | unchecked-lowlevel     | Medium       |
| SU     | suicidal                | High         | UCS    | unchecked-send         | Medium       |
| CDC    | controlled-delegatecall | High         | TO     | tx-origin              | Medium       |
| AS     | arbitrary-send          | High         | TS     | timestamp              | Low          |
| UIS    | uninitialized-state     | High         | BP     | block-other-parameters | Low          |
| UIO    | uninitialized-storage   | High         | LLC    | low-level-calls        | Info         |
| TOD    | TOD-ether/receiver      | High         | MEZ    | msgvalue-equals-zero   | Info         |
| IE     | incorrect-equality      | Medium       | ST     | send-transfer          | Opt          |
| IO     | integer-overflow        | Medium       | BE     | boolean-equal          | Opt          |

We detailed the detection logic of the above contract vulnerability detectors as follows.

## (1) reentrancy-eth (RE)

Ethereum provides three methods to transfer Ethers, i.e., address.send(), address.transfer(), and address.call().value(). These methods all generate a CALL instruction, which reads seven values from the EVM stack. The first three values represent the gas limitation, recipient address, and transfer amounts, respectively. The CALL instruction that meets the following conditions is almost generated by call().value(). (i) the gas limitation is larger than "2300''; (ii) the transfer amount is greater than 0. In addition, the SLOAD instruction is used to get a offset value (named *Slot ID*) from the EVM stack and puts the result read from storage back onto the stack [Ethereum_ledger]. If an SLOAD instruction is executed before the CALL instruction and its *Slot ID* are written by an SSTORE instruction after executing the CALL instruction, it means the CALL instruction can be executed again and cause Reentrancy problem. 

## (2) suicidal (SU)

Unprotected calls to a function executing selfdestruct or suicide statements, which generate a DELEGATECALL instruction to destroy the contract, may cause property damage and business interruption. In order to describe the unprotected behavior, the arbitrary caller address can be defined as there is at least one possible value of the symbolic caller, or the caller is "msg.sender''. In this way, this vulnerability can be detected by verifying that (i) the SELFDESTRUCT instruction can be executed and (ii) the caller belongs the arbitrary addresses. 

## (3) controlled-delegatecall (CDC)

The delegatecall operation of the untrusted addresses may cause unexpected results, such as stealing the contract balance. It works through a DELEGATECALL instruction, so that this vulnerability can be identified by judging (i) the DELEGATECALL instruction is reachable and (ii) the caller is an arbitrary address. 

## (4) arbitrary-send (AS)

This vulnerability refers to the Ether transfer operation can be executed by everyone, since the identifiers of callers are not checked. In this way, it can be detected when the following three conditions are satisfied simultaneously. (i) The CALL instruction of the Ether transfer operation is reachable. (ii) The caller is a arbitrary address. (iii) The Ether value is larger than zero. 

## (5) uninitialized-state (UIS)

The uninitialized state variables may cause unexpected behavior, such as transfer the amount to the zero address. If a variable is meant to be initialized to zero, explicitly set it to zero to improve code readability. At first, uninitialized global variables refer to the value read by SLOAD instruction exists and is not set by the SSTORE instruction. Then, in order to distinguish this vulnerability and UIO, the offset value of SLOAD is further checked whether tainted by ADD instruction, i.e., "ADD'' label, since the member position of storage variables such as \textit{struct} type is calculated by adding the root and member offset of the storage. In this way, this vulnerability is identified when the read offset of SLOAD instruction is not tained by "ADD'' label. 

## (6) uninitialized-storage (UIO)

The uninitialized storage variables will cover the values of other global variables. As mentioned in the detection of UIS, this vulnerability involves the uninitialized global variables and the read offset of SLOAD instruction is tained by the "ADD'' label. Besides, the vulnerability has another situation in which the read offset of SSTORE instruction is tained by the "ADD'' label and the root offset of the storage is zero, which may cause the storage contents to be overwritten. 

## (7) tod-ether/receiver (TOD)

The varying transaction execution sequence may result in different results, so that attackers can prioritize their transactions and manipulate results by launching transactions with higher Gas. Thus, we detect this vulnerability by checking two symbolic transactions that meet the following conditions. (i) They read/story the same global state variables, i.e., the same offset of SLOAD/SSTORE instruction. (ii) The different results can be obtained by swap their sequences. 

## (8) incorrect-equality (IE)

This defect may make a part of code never be executed. It can be detected whether there is a conditional expression that contains the related pattern. BALANCE instruction is used to get the balance of a contract. Its result is tainted with label "BALANCE'' during the path exploration. If a value read by EQ is tainted by "BALANCE'', it means there is a strict check for balance equality in contract. 

## (9) integer-overflow (IO)

The overflow of arithmetic operations of signed and unsigned integers, including addition, subtraction, multiplication, division, modulo, and negation, can result in unexpected results such as withdrawing more Ether than previously deposited. In order to detect the possible overflow operations, we taint the calculation results of instructions such as ADD/SUB/MUL with the label "IOS/IOU'' (sighed/unsighed integers), and check them when the calculation finished by using solvers such as Z3 to solve the inputs that can trigger the integer overflow. Among them, the range of value type (e.g., Uint8) is the key to check values whether out of their scope, while the current tools such as Manticore \cite{ASE_Manticore} only works on Uint256/int256. Also, the paths that include the above situation but end abnormally may be false positives because the exceptions are caused by a "require'' or "assert'' statement that verifies the overflow. 

## (10) unchecked-lowlevel (UCL)

The external call returns a boolean value. If the contract does not check it, the remaining code will continue to be executed when the call fails, causing unexpected behaviors. For example, the user's deposits are reduced but does not get the corresponding Ether. In order to detect this defect, we first locate unchecked CALL instructions by checking whether their return values or taints are read by ISZERO instruction, generated by the condition expression. Then, we determine that CALL is generated by call().value(), which is detailed in the detection of RE. 

## (11) unchecked-send (UCS)

Similar to UCL, this defect can be detected by verifying that unchecked CALL instructions are derived from address.send(), whose gas limitation is a specific value "2300''. 

## (12) tx-origin (TO)

Attackers can bypass the check of tx.origin by using the intermediate calls. In order to identify this defect, we first locate the ORIGIN instruction, which is generated by tx.origin. We then taint its result and check whether there is a taint that is read by an EQ instruction, which is responsible for judging equal values. If the contract contains this kind of contract defect ORIGIN instruction will compare to an address value. Ethereum uses a 40-bit value to indicate an address, and all addresses conform to the EIP55 standard. 

## (13) timestamp (TS)

This defect can allow miners to know the timestamp value previously and further obtain random values. Similar to the detection of IE, the result of TIMESTAMP instruction is tainted by the label "TIMESTAMP'' and this defect will be reported if its taints are used in operations, such as conditional judgments and numerical operations. 

## (14) block-other-parameters (BP)

Similar to TS, this defect can be identified if the taints of other block related instructions are used in operations, e.g., BLOCKHASH, COINBASE, NUMBER, DIFFICULTY, GASLIMIT, and GASPRICE. 

## (15) low-level-calls (LLC)

This informal item is designed to highlight CALL instruction of call().value(), whose gas limitation is not a specific value "2300''. 

## (16) msgvalue-equals-zero (MEZ)

Determining whether msg.value is zero sometimes has no effect. This item can be first located by identifying the CALLVALUE instruction, which is generated by the statement "msg.value''. Meanwhile, its result value is stored in the global context and tainted with "CALLVALUE'' label. Then, this item is detected when the arguments of EQ instruction are zero value and previous stored value (also tainted with "CALLVALUE''). 

## (17) send-transfer (ST)

The operation address.send() can be replaced with address.transfer() to improve the contract security. Thus, this optimization is designed to detect the send operation that meets the following conditions. (i) The gas limitation of CALL instruction is "2300''. (ii) The number of ISZERO instructions until the end of the block is less than 2, so as to distinguish send and transfer operations. 

## (18) boolean-equal (BE)

The boolean variables used in equal judgment waste additional Gas. This optimization can be identified when there exists an EQ instruction whose arguments include boolean values input by PUSH instructions (otherwise false positives), i.e., False (0) and True (1). 